__author__ = "Zakiy Manigo"
__email__ = "zakiymanigo@gmail.com"

#======================================================================#
#*#*#*# Optional: Import any allowed libraries you may need here #*#*#*#
#======================================================================#
import resource
import time
from queue import Queue, PriorityQueue
#=================================#
#*#*#*# Your code ends here #*#*#*#
#=================================#

import argparse

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Robot Path Planning | HW 1 | COMS 4701')
	parser.add_argument('-bfs', action="store_true", default=False , help="Run BFS on the map")
	parser.add_argument('-dfs', action="store_true", default=False, help= "Run DFS on the map")
	parser.add_argument('-astar', action="store_true", default=False, help="Run A* on the map")
	parser.add_argument('-ida', action="store_true", default=False, help="Run Iterative Deepening A* on the map")
	parser.add_argument('-all', action="store_true", default=False, help="Run all the 4 algorithms")
	parser.add_argument('-m', action="store", help="Map filename")

	results = parser.parse_args()

	if results.m=="" or not(results.all or results.astar or results.bfs or results.dfs or results.ida):
		print("Check the parameters : >> python hw1_UNI.py -h")
		exit()

	if results.all:
		results.bfs = results.dfs = results.astar = results.ida = True

	# Reading of map given and all other initializations
	try:
		with open(results.m) as f:
			arena = f.read()
			arena = arena.split("\n")
	except:
		print("Error in reading the arena file.")
		exit()

	# Internal representation
	print(arena)

	print("The arena of size "+ str(len(arena)) + "x" + str(len(arena[0])))
	print("\n".join(arena))

class MazeState:
	'''
	This class is an abstraction to store a maze state, which contains the following:
	- Maze configuration (arena)
	- Current Position (position in the the maze that the current state represents)
	- Parent (the state from which the current state came from)
	- Action (the action taken in the parent state, direction moved, which lead to the creation of the current state)
	- Cost (Cost  of the path taken from the start to the current state)
	- Children (a child of the current state is generated by moving in a direction)
	'''
	
	def get_start_index(self):
		'''
		Returns the start index of the maze based on the given arena
		returns (-1, -1) if no start index found
		'''
		#=======================================================================#
		#*#*#*# TODO: Write your code to find the start index of the maze #*#*#*#
		#=======================================================================#
		
		for row_idx, row in enumerate(self.arena):
			for col_idx, cell in enumerate(row):
				if cell == 's':  # Assuming 's' is the start symbol
					return (row_idx, col_idx)
		return (-1, -1)  # If 's' is not found

		# for row_idx, row in enumerate(self.arena):
		# 	for col_idx, cell in enumerate(row):
		# 		if cell == 's':
		# 			return (row_idx, col_idx)
		# return (-1, -1)
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def get_goal_index(self):
		'''
		Returns the goal index of the maze based on the given arena
		returns (-1, -1) if no goal index found
		'''
		#======================================================================#
		#*#*#*# TODO: Write your code to find the goal index of the maze #*#*#*#
		#======================================================================#

		for row_idx, row in enumerate(self.arena):
			for col_idx, cell in enumerate(row):
				if cell == 'g':
					return (row_idx, col_idx)
		return (-1, -1)
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def __init__(self, arena, parent=None, action='Start', cost=0, current_position=(-1,-1)):

		self.arena = arena
		self.parent = parent
		self.action = action
		self.cost = cost
		self.children = []

		self.start = self.get_start_index()
		self.goal = self.get_goal_index()

		if(current_position[0] == -1):
			self.current_position = self.start
		else:
			self.current_position = current_position

	def display(self):
		print("\n".join(self.arena))

	def move_up(self):
		'''
		This function checks if up is a valid move from the given state.
		If up is a valid move, returns a child in which the player has moved up
		Else returns None.
		'''
		
		#=================================================================#
		#*#*#*# TODO: Write your code to move up in the puzzle here #*#*#*#
		#=================================================================#
		x, y = self.current_position
		if x > 0 and self.arena[x-1][y] != 'o':  # Ensure it's not out of bounds or blocked by an obstacle
			new_arena = self.arena[:]  # Copy the arena (you might need a deeper copy)
			return MazeState(new_arena, parent=self, action='UP', cost=self.cost + 1, current_position=(x-1, y))
		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#


	def move_down(self):
		'''
		This function checks if down is a valid move from the given state.
		If down is a valid move, returns a child in which the player has moved down.
		Else returns None.
		'''
		
		#===================================================================#
		#*#*#*# TODO: Write your code to move down in the puzzle here #*#*#*#
		#===================================================================#
		x, y = self.current_position
		if x < len(self.arena) - 1 and self.arena[x+1][y] != 'o':
			new_arena = self.arena[:]
			return MazeState(new_arena, parent=self, action='DOWN', cost=self.cost + 1, current_position=(x+1, y))
		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def move_left(self):
		'''
		This function checks if left is a valid move from the given state.
		If left is a valid move, returns a child in which the player has moved left.
		Else returns None.
		'''
		
		#===================================================================#
		#*#*#*# TODO: Write your code to move left in the puzzle here #*#*#*#
		#===================================================================#
		x, y = self.current_position
		if y > 0 and self.arena[x][y-1] != 'o':
			new_arena = self.arena[:]
			return MazeState(new_arena, parent=self, action='LEFT', cost=self.cost + 1, current_position=(x, y-1))
		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#


	def move_right(self):
		'''
		This function checks if left is a valid move from the given state.
		If left is a valid move, returns a child in which the player has moved left.
		Else returns None.
		'''
		
		#====================================================================#
		#*#*#*# TODO: Write your code to move right in the puzzle here #*#*#*#
		#====================================================================#
		x, y = self.current_position
		if y < len(self.arena[0]) - 1 and self.arena[x][y+1] != 'o':
			new_arena = self.arena[:]
			return MazeState(new_arena, parent=self, action='RIGHT', cost=self.cost + 1, current_position=(x, y+1))
		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def expand(self):
		""" 
		Generate the child nodes of this node 
		"""
		
		if(len(self.children) != 0):
			return self.children

		# Do not change the order in this function, since the grading script assumes this order of expansion when checking
		children = [self.move_up(), self.move_right(), self.move_down(), self.move_left()]

		self.children = [state for state in children if state is not None]
		return self.children
		
	def __hash__(self):
		'''
		Maze states hashed based on cost. 
		This function may be modified if required.
		'''
		#============================================================================================#
		#*#*#*# Optional: May be modified if your algorithm requires a different hash function #*#*#*#
		#============================================================================================#
		
		return self.cost
		
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#
		
	def __eq__(self, other):
		'''
		Maze states are defined as equal if they have the same dimensions and the same current position. 
		This function may be modified if required.
		'''
		
		#=============================================================================================#
		#*#*#*# Optional: May be modified if your algorithm requires a different equality check #*#*#*#
		#=============================================================================================#
		
		m1 = self.arena
		m2 = other.arena

		if(len(m1) != len(m2)):
			return False

		for i in range(0, len(m1)):
			if(not (m1[i] == m2[i])):
				return False
				
		return self.current_position == other.current_position
		
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#
		
	#=====================================================================================#
	#*#*#*# Optional: Write any other functions you may need in the MazeState Class #*#*#*#
	#=====================================================================================#

	def heuristic(self):
		# Manhattan distance heuristic
		goal_x, goal_y = self.goal
		current_x, current_y = self.current_position
		return abs(goal_x - current_x) + abs(goal_y - current_y)
	
	def __lt__(self, other):
		return self.cost + self.heuristic() < other.cost + other.heuristic()
	
	def __str__(self):
		# Return a string representation of the state, e.g., the arena as a list of strings
		return "\n".join(self.arena)
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#



#================================================================================#
#*#*#*# Optional: You may write helper functions in this space if required #*#*#*#
#================================================================================#

def search(state, g, threshold, path, nodes_expanded):
    f = g + state.heuristic()
    
    if f > threshold:
        return f
    
    if state.current_position == state.goal:
        path.append(state)
        return "FOUND"
    
    nodes_expanded += 1
    min_cost = float('inf')
    
    for child in state.expand():
        result = search(child, g + 1, threshold, path, nodes_expanded)
        
        if result == "FOUND":
            return "FOUND"
        
        if result < min_cost:
            min_cost = result
            
    return min_cost

#=================================#
#*#*#*# Your code ends here #*#*#*#
#=================================#


'''
This function runs Breadth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def bfs(arena):

	#=================================================#
	#*#*#*# TODO: Write your BFS algorithm here #*#*#*#
	#=================================================#
	start_time = time.time()
	initial_state = MazeState(arena)
	frontier = Queue()
	frontier.put(initial_state)
	visited = set()
	visited.add(initial_state)

	nodes_expanded = 0
	while not frontier.empty():
		current_state = frontier.get()

		if current_state.current_position == current_state.goal:
			elapsed_time = time.time() - start_time
			ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
			return current_state.arena, current_state.cost, nodes_expanded, len(visited), current_state.cost, elapsed_time, ram_usage

		nodes_expanded += 1

		for child in current_state.expand():
			if child not in visited:
				visited.add(child)
				frontier.put(child)

	elapsed_time = time.time() - start_time
	ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
	return [], -1, nodes_expanded, len(visited), -1, elapsed_time, ram_usage
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

'''
This function runs Depth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def dfs(arena):
    # Start measuring time for performance evaluation
    start_time = time.time()
    initial_state = MazeState(arena)
    
    # Use a stack for DFS
    stack = []
    stack.append(initial_state)
    visited = set()
    visited.add(initial_state)

    nodes_expanded = 0

    while stack:
        current_state = stack.pop()  # Pop in URDL order

        if current_state.current_position == current_state.goal:
            elapsed_time = time.time() - start_time
            ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            return current_state.arena, current_state.cost, nodes_expanded, len(visited), current_state.cost, elapsed_time, ram_usage

        nodes_expanded += 1

        # Push children onto the stack in reverse order (URDL)
        children = current_state.expand()
        # Push in reverse order to achieve URDL pop order
        for child in reversed(children):
            if child not in visited:
                visited.add(child)
                stack.append(child)

    elapsed_time = time.time() - start_time
    ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    return [], -1, nodes_expanded, len(visited), -1, elapsed_time, ram_usage


	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

'''
This function runs A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def astar(arena):

	#================================================#
	#*#*#*# TODO: Write your A* algorithm here #*#*#*#
	#================================================#
    start_time = time.time()
    initial_state = MazeState(arena)
    frontier = PriorityQueue()
    frontier.put((0 + initial_state.heuristic(), initial_state))  
    visited = set()

    nodes_expanded = 0
    while not frontier.empty():
        priority, current_state = frontier.get()
        
        if current_state.current_position == current_state.goal:
            elapsed_time = time.time() - start_time
            ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            # Return the solved arena and the other metrics
            return current_state.arena, current_state.cost, nodes_expanded, 0, 0, elapsed_time, ram_usage
        
        nodes_expanded += 1
        for child in current_state.expand():
            if child.current_position not in visited:
                visited.add(child.current_position)
                frontier.put((child.cost + child.heuristic(), child))

    # Return an empty list and default values for the other metrics when no solution is found
    elapsed_time = time.time() - start_time
    ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    return [], -1, nodes_expanded, 0, 0, elapsed_time, ram_usage
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#
	
'''
This function runs Iterative Deepening A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def ida(arena):

	#=================================================#
	#*#*#*# TODO: Write your IDA algorithm here #*#*#*#
	#=================================================#
    start_time = time.time()
    initial_state = MazeState(arena)
    
    # Initialize the threshold and the path
    threshold = initial_state.heuristic()
    nodes_expanded = 0
    
    while True:
        path = []
        cost = search(initial_state, 0, threshold, path, nodes_expanded)
        
        if cost == "FOUND":
            elapsed_time = time.time() - start_time
            ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            return path, initial_state.cost, nodes_expanded, 0, 0, elapsed_time, ram_usage
        
        if cost == float('inf'):
            elapsed_time = time.time() - start_time
            ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            return [], -1, nodes_expanded, 0, 0, elapsed_time, ram_usage
        
        threshold = cost  # Increase threshold to the minimum cost that exceeded the threshold
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

if __name__ == "__main__":
	if results.bfs:
		print("\nBFS algorithm called")
		bfs_arena, bfs_cost, bfs_nodes_expanded, bfs_max_nodes_stored, bfs_max_search_depth, bfs_time, bfs_ram = bfs(arena)
		print("\n".join(bfs_arena))
		print("BFS:")
		print("Cost: " + str(bfs_cost))
		print("Nodes Expanded: " + str(bfs_nodes_expanded))
		print("Max Nodes Stored: " + str(bfs_max_nodes_stored))
		print("Max Search Depth: " + str(bfs_max_search_depth))
		print("Time: " + str(bfs_time) + "s")
		print("RAM Usage: " + str(bfs_ram) + "kB\n")

	if results.dfs:
		print("\nDFS algorithm called")
		dfs_arena, dfs_cost, dfs_nodes_expanded, dfs_max_nodes_stored, dfs_max_search_depth, dfs_time, dfs_ram = dfs(arena)
		print("\n".join(dfs_arena))
		print("DFS:")
		print("Cost: " + str(dfs_cost))
		print("Nodes Expanded: " + str(dfs_nodes_expanded))
		print("Max Nodes Stored: " + str(dfs_max_nodes_stored))
		print("Max Search Depth: " + str(dfs_max_search_depth))
		print("Time: " + str(dfs_time) + "s")
		print("RAM Usage: " + str(dfs_ram) + "kB\n")

	if results.astar:
		print("\nA* algorithm called")
		astar_arena, astar_cost, astar_nodes_expanded, astar_max_nodes_stored, astar_max_search_depth, astar_time, astar_ram = astar(arena)
		print("\n".join(astar_arena))
		print("A*:")
		print("Cost: " + str(astar_cost))
		print("Nodes Expanded: " + str(astar_nodes_expanded))
		print("Max Nodes Stored: " + str(astar_max_nodes_stored))
		print("Max Search Depth: " + str(astar_max_search_depth))
		print("Time: " + str(astar_time) + "s")
		print("RAM Usage: " + str(astar_ram) + "kB\n")
	
	if results.ida:
		print("\nIterative Deepening A* algorithm called")
		ida_arena, ida_cost, ida_nodes_expanded, ida_max_nodes_stored, ida_max_search_depth, ida_time, ida_ram = ida(arena)
		print("\n".join(ida_arena))
		print("Iterative Deepening A*:")
		print("Cost: " + str(ida_cost))
		print("Nodes Expanded: " + str(ida_nodes_expanded))
		print("Max Nodes Stored: " + str(ida_max_nodes_stored))
		print("Max Search Depth: " + str(ida_max_search_depth))
		print("Time: " + str(ida_time) + "s")
		print("RAM Usage: " + str(ida_ram) + "kB\n")