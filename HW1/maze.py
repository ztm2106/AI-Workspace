#======================================================================#
# Optional: Import any allowed libraries you may need here
#======================================================================#

import argparse
import time
import resource
from collections import deque
from queue import PriorityQueue

#=================================#
# Your code ends here
#=================================#

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Robot Path Planning | HW 1 | COMS 4701')
    parser.add_argument('-bfs', action="store_true", default=False , help="Run BFS on the map")
    parser.add_argument('-dfs', action="store_true", default=False, help= "Run DFS on the map")
    parser.add_argument('-astar', action="store_true", default=False, help="Run A* on the map")
    parser.add_argument('-ida', action="store_true", default=False, help="Run Iterative Deepening A* on the map")
    parser.add_argument('-all', action="store_true", default=False, help="Run all the 4 algorithms")
    parser.add_argument('-m', action="store", help="Map filename")

    results = parser.parse_args()

    if results.m == "" or not(results.all or results.astar or results.bfs or results.dfs or results.ida):
        print("Check the parameters : >> python hw1_UNI.py -h")
        exit()

    if results.all:
        results.bfs = results.dfs = results.astar = results.ida = True

    # Reading of map given and all other initializations
    try:
        with open(results.m) as f:
            arena = f.read()
            arena = arena.split("\n")
    except:
        print("Error in reading the arena file.")
        exit()

    # Internal representation
    print(arena)

    print("The arena of size "+ str(len(arena)) + "x" + str(len(arena[0])))
    print("\n".join(arena))

class MazeState:
    '''
    This class is an abstraction to store a maze state, which contains the following:
    - Maze configuration (arena)
    - Current Position (position in the the maze that the current state represents)
    - Parent (the state from which the current state came from)
    - Action (the action taken in the parent state, direction moved, which lead to the creation of the current state)
    - Cost (Cost  of the path taken from the start to the current state)
    - Children (a child of the current state is generated by moving in a direction)
    '''

    def get_start_index(self):
        '''
        Returns the start index of the maze based on the given arena
        returns (-1, -1) if no start index found
        '''
        #=======================================================================#
        # TODO: Write your code to find the start index of the maze
        #=======================================================================#
        for i, row in enumerate(self.arena):
            for j, cell in enumerate(row):
                if cell == 's':
                    return (i, j)
        return (-1, -1)
        #=================================#
        # Your code ends here
        #=================================#

    def get_goal_index(self):
        '''
        Returns the goal index of the maze based on the given arena
        returns (-1, -1) if no goal index found
        '''
        #======================================================================#
        # TODO: Write your code to find the goal index of the maze
        #======================================================================#
        for i, row in enumerate(self.arena):
            for j, cell in enumerate(row):
                if cell == 'g':
                    return (i, j)
        return (-1, -1)
        #=================================#
        # Your code ends here
        #=================================#

    def __init__(self, arena, parent=None, action='Start', cost=0, current_position=(-1,-1)):
        self.arena = arena
        self.parent = parent
        self.action = action
        self.cost = cost
        self.children = []

        self.start = self.get_start_index()
        self.goal = self.get_goal_index()

        if(current_position[0] == -1):
            self.current_position = self.start
        else:
            self.current_position = current_position

    def display(self):
        print("\n".join(self.arena))

    def move_up(self):
        '''
        This function checks if up is a valid move from the given state.
        If up is a valid move, returns a child in which the player has moved up
        Else returns None.
        '''

        #=================================================================#
        # TODO: Write your code to move up in the puzzle here
        #=================================================================#
        x, y = self.current_position
        if x > 0 and self.arena[x-1][y] != 'o':
            return MazeState(
                self.arena, self, 'Up', self.cost + 1, (x - 1, y)
            )
        return None

        #=================================#
        # Your code ends here
        #=================================#

    def move_down(self):
        '''
        This function checks if down is a valid move from the given state.
        If down is a valid move, returns a child in which the player has moved down.
        Else returns None.
        '''

        #===================================================================#
        # TODO: Write your code to move down in the puzzle here
        #===================================================================#
        x, y = self.current_position
        if x < len(self.arena) - 1:
            target_cell = self.arena[x + 1][y]
            if target_cell != 'o':
                new_arena = self.arena.copy()
                return MazeState(
                    new_arena,
                    parent=self,
                    action='Down',
                    cost=self.cost + 1,
                    current_position=(x + 1, y)
                )
        return None
        #=================================#
        # Your code ends here
        #=================================#

    def move_left(self):
        '''
        This function checks if left is a valid move from the given state.
        If left is a valid move, returns a child in which the player has moved left.
        Else returns None.
        '''

        #===================================================================#
        # TODO: Write your code to move left in the puzzle here
        #===================================================================#
        x, y = self.current_position
        if y > 0:
            target_cell = self.arena[x][y - 1]
            if target_cell != 'o':
                new_arena = self.arena.copy()
                return MazeState(
                    new_arena,
                    parent=self,
                    action='Left',
                    cost=self.cost + 1,
                    current_position=(x, y - 1)
                )
        return None
        #=================================#
        # Your code ends here
        #=================================#

    def move_right(self):
        '''
        This function checks if right is a valid move from the given state.
        If right is a valid move, returns a child in which the player has moved right.
        Else returns None.
        '''

        #====================================================================#
        # TODO: Write your code to move right in the puzzle here
        #====================================================================#
        x, y = self.current_position
        if y < len(self.arena[0]) - 1:
            target_cell = self.arena[x][y + 1]
            if target_cell != 'o':
                new_arena = self.arena.copy()
                return MazeState(
                    new_arena,
                    parent=self,
                    action='Right',
                    cost=self.cost + 1,
                    current_position=(x, y + 1)
                )
        return None
        #=================================#
        # Your code ends here
        #=================================#

    def expand(self):
        """
        Generate the child nodes of this node
        """

        if(len(self.children) != 0):
            return self.children

        # Do not change the order in this function, since the grading script assumes this order of expansion when checking
        children = [self.move_up(), self.move_right(), self.move_down(), self.move_left()]

        self.children = [state for state in children if state is not None]
        return self.children

    def __hash__(self):
        '''
        Maze states hashed based on current position.
        This function may be modified if required.
        '''

        return hash((self.current_position, tuple(self.arena)))

    def __eq__(self, other):
        '''
        Maze states are defined as equal if they have the same current position.
        This function may be modified if required.
        '''

        return self.current_position == other.current_position and self.arena == other.arena
    
    def __lt__(self, other):
        # Define how to compare this state with another based on the cost or f value
        return self.cost < other.cost

    # Optional: Write any other functions you may need in the MazeState Class
    def path(self):
        '''
        Returns the path from the start state to the current state
        '''
        current = self
        path = []
        while current.parent is not None:
            path.append(current)
            current = current.parent
        path.append(current)
        path.reverse()
        return path

    def get_depth(self):
        '''
        Returns the depth of the node in the search tree
        '''
        depth = 0
        current = self
        while current.parent is not None:
            depth += 1
            current = current.parent
        return depth

# Optional: You may write helper functions in this space if required

def reconstruct(state):
    '''
    Reconstructs the solution path and updates the arena to display the path
    '''
    path = state.path()
    new_arena_solution = [list(row) for row in state.arena]
    for s in path[1:-1]:  # Exclude start and goal
        x, y = s.current_position
        if new_arena_solution[x][y] not in ('s', 'g'):
            new_arena_solution[x][y] = '.'
    new_arena_solution = [''.join(row) for row in new_arena_solution]
    return new_arena_solution

def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])


def ida_search(node, g, threshold, visited):
    f = g + heuristic(node.current_position, node.goal)
    if f > threshold:
        return f, 1, 1, node.get_depth()
    if node.current_position == node.goal:
        return node, 1, 1, node.get_depth()
    min_threshold = float('inf')
    nodes_expanded = 1
    max_nodes_stored = 1
    visited.add(node.current_position)
    for child in node.expand():
        if child.current_position not in visited:
            temp, nodes, max_nodes, depth = ida_search(child, g + 1, threshold, visited)
            nodes_expanded += nodes
            max_nodes_stored = max(max_nodes_stored, max_nodes)
            if isinstance(temp, MazeState):
                return temp, nodes_expanded, max_nodes_stored, depth
            if temp < min_threshold:
                min_threshold = temp
    visited.remove(node.current_position)
    return min_threshold, nodes_expanded, max_nodes_stored, node.get_depth()

#=================================#
# Your code ends here
#=================================#

'''
This function runs Breadth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def bfs(arena):

    #=================================================#
    # TODO: Write your BFS algorithm here
    #=================================================#
    start_time = time.time()
    start_state = MazeState(arena)
    frontier = deque([start_state])
    explored = set()
    nodes_expanded = 0
    max_nodes_stored = 1
    max_search_depth = 0

    while frontier:
        current_state = frontier.popleft()
        nodes_expanded += 1
        explored.add(current_state.current_position)
        max_search_depth = max(max_search_depth, current_state.get_depth())

        if current_state.current_position == current_state.goal:
            end_time = time.time()
            ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            new_arena_solution = reconstruct(current_state)
            return (new_arena_solution, current_state.cost, nodes_expanded, max_nodes_stored, max_search_depth, end_time - start_time, ram_usage)

        for child in current_state.expand():
            if child.current_position not in explored and child not in frontier:
                frontier.append(child)
                explored.add(child.current_position)
                max_nodes_stored = max(max_nodes_stored, len(frontier) + len(explored))

    end_time = time.time()
    ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    return (arena, -1, nodes_expanded, max_nodes_stored, max_search_depth, end_time - start_time, ram_usage)
    #=================================#
    # Your code ends here
    #=================================#

'''
This function runs Depth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def dfs(arena):

    #=================================================#
    # TODO: Write your DFS algorithm here
    #=================================================#
    start_time = time.time()
    start_state = MazeState(arena)
    frontier = [start_state]
    explored = set()
    nodes_expanded = 0
    max_nodes_stored = 1
    max_search_depth = 0

    while frontier:
        current_state = frontier.pop()
        nodes_expanded += 1
        explored.add(current_state.current_position)
        max_search_depth = max(max_search_depth, current_state.get_depth())

        if current_state.current_position == current_state.goal:
            end_time = time.time()
            ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            new_arena_solution = reconstruct(current_state)
            return (new_arena_solution, current_state.cost, nodes_expanded, max_nodes_stored, max_search_depth, end_time - start_time, ram_usage)

        for child in reversed(current_state.expand()):  # Reverse to ensure DFS order (Up, Right, Down, Left)
            if child.current_position not in explored and child not in frontier:
                frontier.append(child)
                explored.add(child.current_position)
                max_nodes_stored = max(max_nodes_stored, len(frontier) + len(explored))

    end_time = time.time()
    ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    return (arena, -1, nodes_expanded, max_nodes_stored, max_search_depth, end_time - start_time, ram_usage)
    #=================================#
    # Your code ends here
    #=================================#

'''
This function runs A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def astar(arena):

    #================================================#
    # TODO: Write your A* algorithm here
    #================================================#
    start_time = time.time()
    start_state = MazeState(arena)
    frontier = PriorityQueue()
    frontier.put((0, start_state))
    explored = set()
    nodes_expanded = 0
    max_nodes_stored = 1
    max_search_depth = 0

    while not frontier.empty():
        _, current_state = frontier.get()
        nodes_expanded += 1
        explored.add(current_state.current_position)
        max_search_depth = max(max_search_depth, current_state.get_depth())

        if current_state.current_position == current_state.goal:
            end_time = time.time()
            ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            new_arena_solution = reconstruct(current_state)
            return (new_arena_solution, current_state.cost, nodes_expanded, max_nodes_stored, max_search_depth, end_time - start_time, ram_usage)

        for child in current_state.expand():
            if child.current_position not in explored:
                f_value = child.cost + heuristic(child.current_position, child.goal)
                frontier.put((f_value, child))
                explored.add(child.current_position)
                max_nodes_stored = max(max_nodes_stored, frontier.qsize() + len(explored))

    end_time = time.time()
    ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    return (arena, -1, nodes_expanded, max_nodes_stored, max_search_depth, end_time - start_time, ram_usage)

    #=================================#
    # Your code ends here
    #=================================#

'''
This function runs Iterative Deepening A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def ida(arena):

    #=================================================#
    # TODO: Write your IDA algorithm here
    #=================================================#
    start_time = time.time()
    start_state = MazeState(arena)
    threshold = heuristic(start_state.current_position, start_state.goal)
    nodes_expanded = 0
    max_nodes_stored = 1
    max_search_depth = 0

    while True:
        temp, nodes, max_nodes, depth = ida_search(start_state, 0, threshold, set())
        nodes_expanded += nodes
        max_nodes_stored = max(max_nodes_stored, max_nodes)
        max_search_depth = max(max_search_depth, depth)
        if isinstance(temp, MazeState):
            end_time = time.time()
            ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            new_arena_solution = reconstruct(temp)
            return (new_arena_solution, temp.cost, nodes_expanded, max_nodes_stored, max_search_depth, end_time - start_time, ram_usage)
        if temp == float('inf'):
            end_time = time.time()
            ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            return (arena, -1, nodes_expanded, max_nodes_stored, max_search_depth, end_time - start_time, ram_usage)
        threshold = temp
    #=================================
    # Your code ends here
    #=================================#


if __name__ == "__main__":
    if results.bfs:
        print("\nBFS algorithm called")
        bfs_arena, bfs_cost, bfs_nodes_expanded, bfs_max_nodes_stored, bfs_max_search_depth, bfs_time, bfs_ram = bfs(arena)
        print("\n".join(bfs_arena))
        print("BFS:")
        print("Cost: " + str(bfs_cost))
        print("Nodes Expanded: " + str(bfs_nodes_expanded))
        print("Max Nodes Stored: " + str(bfs_max_nodes_stored))
        print("Max Search Depth: " + str(bfs_max_search_depth))
        print("Time: " + str(bfs_time) + "s")
        print("RAM Usage: " + str(bfs_ram) + "kB\n")

    if results.dfs:
        print("\nDFS algorithm called")
        dfs_arena, dfs_cost, dfs_nodes_expanded, dfs_max_nodes_stored, dfs_max_search_depth, dfs_time, dfs_ram = dfs(arena)
        print("\n".join(dfs_arena))
        print("DFS:")
        print("Cost: " + str(dfs_cost))
        print("Nodes Expanded: " + str(dfs_nodes_expanded))
        print("Max Nodes Stored: " + str(dfs_max_nodes_stored))
        print("Max Search Depth: " + str(dfs_max_search_depth))
        print("Time: " + str(dfs_time) + "s")
        print("RAM Usage: " + str(dfs_ram) + "kB\n")

    if results.astar:
        print("\nA* algorithm called")
        astar_arena, astar_cost, astar_nodes_expanded, astar_max_nodes_stored, astar_max_search_depth, astar_time, astar_ram = astar(arena)
        print("\n".join(astar_arena))
        print("A*:")
        print("Cost: " + str(astar_cost))
        print("Nodes Expanded: " + str(astar_nodes_expanded))
        print("Max Nodes Stored: " + str(astar_max_nodes_stored))
        print("Max Search Depth: " + str(astar_max_search_depth))
        print("Time: " + str(astar_time) + "s")
        print("RAM Usage: " + str(astar_ram) + "kB\n")

    if results.ida:
        print("\nIterative Deepening A* algorithm called")
        ida_arena, ida_cost, ida_nodes_expanded, ida_max_nodes_stored, ida_max_search_depth, ida_time, ida_ram = ida(arena)
        print("\n".join(ida_arena))
        print("Iterative Deepening A*:")
        print("Cost: " + str(ida_cost))
        print("Nodes Expanded: " + str(ida_nodes_expanded))
        print("Max Nodes Stored: " + str(ida_max_nodes_stored))
        print("Max Search Depth: " + str(ida_max_search_depth))
        print("Time: " + str(ida_time) + "s")
        print("RAM Usage: " + str(ida_ram) + "kB\n")
